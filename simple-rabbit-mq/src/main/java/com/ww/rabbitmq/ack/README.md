## 消息确认

消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成了部分突然它挂掉了，会发生什么情况。RabbitMQ 一旦向消费者传递了 一条消息，便立即将该消
息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息。以及后续发送给该消费这的消息，因为它无法接收到。 为了保证消息在发送过程中不丢失，rabbitmq
引入消息应答机制，消息应答就是：消费者在接收到消息并且处理该消息之后，告诉 rabbitmq 它已经处理了， rabbitmq 可以把该消息删除了。

### 自动确认模式

在自动确认模式下，消息在发送后(写入TCP套接字)立即被视为成功传递。这种模式需要在高吞吐量和数据传输安全性方面做权衡。这种模式通常被称为“一劳永逸”。
与手动确认模式不同，如果消费者的TCP连接或通道在成功传递之前关闭，服务器发送的消息将丢失。因此，自动消息确认应该被认为是不安全的，并且不适合所有工作负载。

使用自动确认模式时需要考虑的另一件重要事情是消费者过载。手动确认模式通常与限制信道上未完成(“进行中”)
递送的数量的有界信道预取一起使用。然而，对于自动确认，定义上没有这样的限制。因此，交付速度可能会让消费者不堪重负，这可能会在内存中积累积压并耗尽堆，或者让操作系统终止他们的进程。一些客户端库将施加TCP反压(
停止从套接字读取，直到未处理的交付的积压下降到超过一定的限制为止)。因此，仅向能够高效、稳定地处理送货的消费者推荐自动确认模式。

### 手动确认模式

RabbitMQ认为消息在接收到显式(“手动”)客户端确认时成功传递。手动发送的确认可以是肯定的，也可以是否定的，并使用以下协议方法之一：

- basic.ack 用于肯定确认。
- basic.nack 用于否定确认。
- basic.reject 用于否定确认，但与basic.nack相比有一个限制。

肯定确认只是指示RabbitMQ将消息记录为已送达，并且可以丢弃。带有basic.reject的否定确认具有相同的效果。不同之处主要在于语义：肯定确认假设消息已成功处理，而否定确认则表明传递未处理，但仍应删除。

可以对手动确认进行批处理，以减少网络流量。这是通过将确认方法的multiple字段设置为true来实现的。当Multiple字段设置为true时，RabbitMQ将确认指定的标签之前(包括该标签)
的所有未完成交付标签。与确认相关的所有其他内容一样，这是按通道确定作用域的。例如，假设在信道CH上存在未确认的传送标签5、6、7和8，当确认帧到达该信道时，其中Delivery_Tag设置为8并且Multiple设置为TRUE，则将确认从5到8的所有标签。如果将Multiple设置为False，则仍将不确认deliveries
5、6和7。

有时，消费者不能立即处理交付，但其他实例可能可以。在这种情况下，可能希望将其重新排队，并让另一消费者接收和处理它。basic.reject和basic.nack是用于此目的的两个协议方法。

这些方法通常用于否定确认交付。这样的交付可以由broker丢弃或重新排队。此行为由requeue字段控制。当该字段设置为true时，代理将使用指定的交付标签重新排队交付。

当消息重新排队时，如果可能，它将被放置到其队列中的原始位置。如果不是(由于多个消费者共享一个队列时来自其他消费者的并发交付和确认)，消息将被重新排队到更靠近队列头的位置。

重新排队的消息可能会立即准备好重新传递，具体取决于它们在队列中的位置以及具有活动使用者的通道使用的预取值。这意味着，如果所有消费者因为暂时情况而无法处理交付而重新排队，他们将创建重新排队/重新交付循环。就网络带宽和CPU资源而言，这样的环路可能代价高昂。消费者实现可以跟踪重新传递的次数，并永久拒绝消息(
丢弃它们)或安排延迟后的重新排队。

可以使用basic.nack方法一次拒绝或重新排队多个消息。这就是它与basic.reject的不同之处。它接受一个附加参数multiple。

使用手动确认时，当发生传递的通道(或连接)关闭时，任何未确认的传递(消息)都会自动重新排队。这包括客户端造成的TCP连接丢失、消费者应用程序(进程)故障和通道级协议异常。 请注意，检测不可用的客户端需要一段时间。

如果客户端不止一次确认相同的递送标签，RabbitMQ将导致诸如`PRECONDITION_FAILED - unknown delivery tag 100`之类的通道错误。如果使用未知的传递标记，则会抛出相同的通道异常。

代理将抱怨“unknown delivery tag”的另一种情况是，当在与接收递送的信道不同的信道上尝试确认(无论是肯定的还是否定的)时。Deliveries必须在同一渠道上确认。















